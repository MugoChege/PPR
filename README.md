# ABOUT THIS BODY OF WORK
This is my portfolio that attempts to show the skill-set that I have and the different approaches that I use in solving programming challenges. In my journey to becoming and being a programmer I have found a number of skills necessary but in this particular case two skills stand out; having good logic and understanding the probabilities and possibilities associated with a particular issue.  
The counter argument to the existence of this body of work based on logic and probability (which was stated to be essential earlier on) is that the only way one can be verified as a skilled programmer is if they are placed in a empty room with an observer and told to program. The resulting programs made should be to the standard set by the observer. Which basically voids the whole purpose of the existence of the aforementioned body of work. Nonetheless, this is the best solution that is currently available to gauge skill-set.
Throughout the code within the portfolio, the use of libraries, frameworks and 'borrowed' code is either avoided or used minimally. Most if not all the code is written from a blank concept. The reason for this is the reason behind the existence of libraries, frameworks and 'borrowed' code is not taken to account during the implementation of the solutions within the portfolio and it is a way for me to challenge myself to find solutions to the challenges. Also, the 'one size fits all' approach at least in my previous experience has led to inefficiencies in their resulting programs, I however acknowledge the benefit of the speed of production they bring and I am willing to learn them contextually.
For each of the programming challenges, solutions have been made in the following languages C, C++, C#, Java, Kotlin, Rust, Swift, Python, Ruby, JavaScript and PHP. The reason for this is both to re-enforce my learning and understanding of the respective languages and getting to internalize the different approaches to their functioning and the subtle difference that they have in comparison to each other. Lastly, it is to enable me to write native code to different platforms that have the same operational logic.
